--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -541,6 +541,16 @@ struct sched_entity {
 	/* cached value of my_q->h_nr_running */
 	unsigned long			runnable_weight;
 #endif
+
+#ifdef CONFIG_SCHED_BORE
+	u64				burst_time;
+	u8				bore_score;
+#ifdef CONFIG_SCHED_GRAPH_BURST
+	u64				burst_pred;
+	u64				dep_weight;
+	u32				graph_boost;
+#endif
+#endif
 
 #ifdef CONFIG_SMP
 	/*
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -21,6 +21,43 @@
  *  Graph-Burst EEVDF: Topology-aware burst prediction for IEEE Access Research.
  */
 
+#ifdef CONFIG_SCHED_GRAPH_BURST
+static void update_graph_dep_weight(struct sched_entity *se)
+{
+	struct sched_entity *parent = se->parent;
+	u64 sibling_load = 0;
+
+	/* Local MWIS simulation: weight = my_load / (1 + sum_of_neighbor_loads) */
+	if (parent && parent->my_q)
+		sibling_load = parent->my_q->avg_load;
+
+	se->dep_weight = (se->load.weight << 10) / (1 + sibling_load);
+	
+	/* EWMA: 75% history + 25% current burst */
+	se->burst_pred = (se->burst_pred * 3 + se->burst_time) >> 2;
+
+	/* Final Boost Calculation */
+	se->graph_boost = (u32)(se->dep_weight * (1 + (se->burst_pred >> 20)));
+}
+
+static void apply_graph_burst_limit(struct sched_entity *se, u64 *vruntime)
+{
+	if (se->graph_boost > 1024)
+		*vruntime -= (*vruntime * (se->graph_boost - 1024)) >> 16;
+}
+#endif
+
+#ifdef CONFIG_SCHED_BORE
+static void update_bore_stats(struct sched_entity *se, u64 delta_exec)
+{
+	se->burst_time += delta_exec;
+	/* Simple score calculation for baseline */
+	se->bore_score = fls64(se->burst_time) >> 1;
+#ifdef CONFIG_SCHED_GRAPH_BURST
+	update_graph_dep_weight(se);
+#endif
+}
+#endif
+
 /*
  * EEVDF: Earliest Eligible Virtual Deadline First
@@ -1124,6 +1161,11 @@ static void update_curr(struct cfs_rq *cfs_rq)
 	curr->vruntime += calc_delta_fair(delta_exec, curr);
 	update_deadline(cfs_rq, curr);
 	update_min_vruntime(cfs_rq);
+
+#ifdef CONFIG_SCHED_BORE
+	update_bore_stats(curr, delta_exec);
+#endif
+
 }
 
 static void update_entity_lag(struct cfs_rq *cfs_rq, struct sched_entity *se)
@@ -1131,6 +1173,11 @@ static void update_entity_lag(struct cfs_rq *cfs_rq, struct sched_entity *se)
 	s64 lag, limit;
 
 	if (entity_is_task(se)) {
+#ifdef CONFIG_SCHED_GRAPH_BURST
+		apply_graph_burst_limit(se, &se->vruntime);
+#endif
 		limit = calc_delta_fair(max_vruntime_lag, se);
 		lag = avg_vruntime(cfs_rq) - se->vruntime;
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1280,6 +1280,21 @@ config SCHED_BORE
 	  of interactive tasks under heavy load.
 	  If unsure, say Y.
 
+config SCHED_GRAPH_BURST
+	bool "Graph-Burst EEVDF Enhancement"
+	depends on SCHED_BORE
+	default n
+	help
+	  Enables topology-aware burst prediction using local greedy MWIS.
+	  Targeted for low-latency research and IEEE Access publication.
+
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
 	select CGROUPS
